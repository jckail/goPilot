
function loadScript(src, mod = true) {
let s = document.createElement('script');
s.src = src;
if (mod) {
s.type = 'module';
s.async = true;
s.defer = true
}
document.head.appendChild(s);
}
loadScript("/third_party/dialog-polyfill/dialog-polyfill.js", false)
loadScript("/static/frontend/frontend.js");

Skip to Main Content

Why Go
Case Studies
Common problems companies solve with Go
Use Cases
Stories about how and why companies use Go
Security Policy
How Go can help keep you secure by default      Learn    Docs
Effective Go
Tips for writing clear, performant, and idiomatic Go code
Go User Manual
A complete introduction to building software with Go
Standard library
Reference documentation for Go's standard library
Release Notes
Learn what's new in each Go release      Packages    Community
Recorded Talks
Videos from prior events
Meetups
Meet other local Go developers
Conferences
Learn and network with Go developers from around the world
Go blog
The Go project's official blog.
Go project
Get help and stay informed from Go
Get connected


Why Go


Why Go     Case Studies    Use Cases    Security Policy        Learn     Docs


Docs     Effective Go    Go User Manual    Standard library    Release Notes        Packages     Community


Community     Recorded Talks    Meetups       Conferences       Go blog    Go project
Get connected


Discover Packages    github.com/xeipuuv/gojsonschema

gojsonschema  package  module
Version: v1.2.0   Latest  Latest
This package is not in the latest version of its module.     Go to latest     Published: Oct 15, 2019  License: Apache-2.0     Imports: 25     Imported by: 1,347
Main  Versions  Licenses  Imports  Imported By
Details      Valid go.mod file
The Go module system was introduced in Go 1.11 and is the official dependency management
solution for Go.       Redistributable license
Redistributable licenses place minimal restrictions on how software can be used,
modified, and redistributed.       Tagged version
Modules with tagged versions give importers more predictable builds.       Stable version
When a project reaches major version v1 it is considered stable.     Learn more about best practices    Repository
github.com/xeipuuv/gojsonschema   Links     Open Source Insights


README


gojsonschema  Description
An implementation of JSON Schema for the Go  programming language. Supports draft-04, draft-06 and draft-07.
References :   http://json-schema.org  http://json-schema.org/latest/json-schema-core.html  http://json-schema.org/latest/json-schema-validation.html   Installation  go get github.com/xeipuuv/gojsonschema
Dependencies :   github.com/xeipuuv/gojsonpointer  github.com/xeipuuv/gojsonreference  github.com/stretchr/testify/assert   Usage  Example  package main

import (
"fmt"
"github.com/xeipuuv/gojsonschema"
)


func main() {

schemaLoader := gojsonschema.NewReferenceLoader("file:///home/me/schema.json")
documentLoader := gojsonschema.NewReferenceLoader("file:///home/me/document.json")

result, err := gojsonschema.Validate(schemaLoader, documentLoader)
if err != nil {
panic(err.Error())
}

if result.Valid() {
fmt.Printf("The document is valid\n")
} else {
fmt.Printf("The document is not valid. see errors :\n")
for _, desc := range result.Errors() {
fmt.Printf("- %s\n", desc)
}
}
}  Loaders
There are various ways to load your JSON data.
In order to load your schemas and documents,
first declare an appropriate loader :   Web / HTTP, using a reference :   loader := gojsonschema.NewReferenceLoader("http://www.some_host.com/schema.json")   Local file, using a reference :   loader := gojsonschema.NewReferenceLoader("file:///home/me/schema.json")
References use the URI scheme, the prefix (file://) and a full path to the file are required.   JSON strings :   loader := gojsonschema.NewStringLoader(`{"type": "string"}`)   Custom Go types :   m := map[string]interface{}{"type": "string"}
loader := gojsonschema.NewGoLoader(m)
And  type Root struct {
Users []User `json:"users"`
}

type User struct {
Name string `json:"name"`
}

...

data := Root{}
data.Users = append(data.Users, User{"John"})
data.Users = append(data.Users, User{"Sophia"})
data.Users = append(data.Users, User{"Bill"})

loader := gojsonschema.NewGoLoader(data)  Validation
Once the loaders are set, validation is easy :  result, err := gojsonschema.Validate(schemaLoader, documentLoader)
Alternatively, you might want to load a schema only once and process to multiple validations :  schema, err := gojsonschema.NewSchema(schemaLoader)
...
result1, err := schema.Validate(documentLoader1)
...
result2, err := schema.Validate(documentLoader2)
...
// etc ...
To check the result :  if result.Valid() {
fmt.Printf("The document is valid\n")
} else {
fmt.Printf("The document is not valid. see errors :\n")
for _, err := range result.Errors() {
// Err implements the ResultError interface
fmt.Printf("- %s\n", err)
}
}  Loading local schemas
By default file and http(s) references to external schemas are loaded automatically via the file system or via http(s). An external schema can also be loaded using a SchemaLoader .  sl := gojsonschema.NewSchemaLoader()
loader1 := gojsonschema.NewStringLoader(`{ "type" : "string" }`)
err := sl.AddSchema("http://some_host.com/string.json", loader1)
Alternatively if your schema already has an $id you can use the AddSchemas function  loader2 := gojsonschema.NewStringLoader(`{
"$id" : "http://some_host.com/maxlength.json",
"maxLength" : 5
}`)
err = sl.AddSchemas(loader2)
The main schema should be passed to the Compile function. This main schema can then directly reference the added schemas without needing to download them.  loader3 := gojsonschema.NewStringLoader(`{
"$id" : "http://some_host.com/main.json",
"allOf" : [
{ "$ref" : "http://some_host.com/string.json" },
{ "$ref" : "http://some_host.com/maxlength.json" }
]
}`)

schema, err := sl.Compile(loader3)

documentLoader := gojsonschema.NewStringLoader(`"hello world"`)

result, err := schema.Validate(documentLoader)
It's also possible to pass a ReferenceLoader to the Compile function that references a loaded schema.  err = sl.AddSchemas(loader3)
schema, err := sl.Compile(gojsonschema.NewReferenceLoader("http://some_host.com/main.json"))
Schemas added by AddSchema and AddSchemas are only validated when the entire schema is compiled, unless meta-schema validation is used.  Using a specific draft
By default gojsonschema will try to detect the draft of a schema by using the $schema keyword and parse it in a strict draft-04, draft-06 or draft-07 mode. If $schema is missing, or the draft version is not explicitely set, a hybrid mode is used which merges together functionality of all drafts into one mode.
Autodectection can be turned off with the AutoDetect property. Specific draft versions can be specified with the Draft property.  sl := gojsonschema.NewSchemaLoader()
sl.Draft = gojsonschema.Draft7
sl.AutoDetect = false
If autodetection is on (default), a draft-07 schema can savely reference draft-04 schemas and vice-versa, as long as $schema is specified in all schemas.  Meta-schema validation
Schemas that are added using the AddSchema , AddSchemas and Compile can be validated against their meta-schema by setting the Validate property.
The following example will produce an error as multipleOf must be a number. If Validate is off (default), this error is only returned at the Compile step.  sl := gojsonschema.NewSchemaLoader()
sl.Validate = true
err := sl.AddSchemas(gojsonschema.NewStringLoader(`{
$id" : "http://some_host.com/invalid.json",
"$schema": "http://json-schema.org/draft-07/schema#",
"multipleOf" : true
}`))
Errors returned by meta-schema validation are more readable and contain more information, which helps significantly if you are developing a schema.
Meta-schema validation also works with a custom $schema . In case $schema is missing, or AutoDetect is set to false , the meta-schema of the used draft is used.  Working with Errors
The library handles string error codes which you can customize by creating your own gojsonschema.locale and setting it  gojsonschema.Locale = YourCustomLocale{}
However, each error contains additional contextual information.
Newer versions of gojsonschema may have new additional errors, so code that uses a custom locale will need to be updated when this happens.
err.Type() : string Returns the "type" of error that occurred. Note you can also type check. See below
Note: An error of RequiredType has an err.Type() return value of "required"  "required": RequiredError
"invalid_type": InvalidTypeError
"number_any_of": NumberAnyOfError
"number_one_of": NumberOneOfError
"number_all_of": NumberAllOfError
"number_not": NumberNotError
"missing_dependency": MissingDependencyError
"internal": InternalError
"const": ConstEror
"enum": EnumError
"array_no_additional_items": ArrayNoAdditionalItemsError
"array_min_items": ArrayMinItemsError
"array_max_items": ArrayMaxItemsError
"unique": ItemsMustBeUniqueError
"contains" : ArrayContainsError
"array_min_properties": ArrayMinPropertiesError
"array_max_properties": ArrayMaxPropertiesError
"additional_property_not_allowed": AdditionalPropertyNotAllowedError
"invalid_property_pattern": InvalidPropertyPatternError
"invalid_property_name":  InvalidPropertyNameError
"string_gte": StringLengthGTEError
"string_lte": StringLengthLTEError
"pattern": DoesNotMatchPatternError
"multiple_of": MultipleOfError
"number_gte": NumberGTEError
"number_gt": NumberGTError
"number_lte": NumberLTEError
"number_lt": NumberLTError
"condition_then" : ConditionThenError
"condition_else" : ConditionElseError
err.Value() : interface{} Returns the value given
err.Context() : gojsonschema.JsonContext Returns the context. This has a String() method that will print something like this: (root).firstName
err.Field() : string Returns the fieldname in the format firstName, or for embedded properties, person.firstName. This returns the same as the String() method on err.Context() but removes the (root). prefix.
err.Description() : string The error description. This is based on the locale you are using. See the beginning of this section for overwriting the locale with a custom implementation.
err.DescriptionFormat() : string The error description format. This is relevant if you are adding custom validation errors afterwards to the result.
err.Details() : gojsonschema.ErrorDetails Returns a map[string]interface{} of additional error details specific to the error. For example, GTE errors will have a "min" value, LTE will have a "max" value. See errors.go for a full description of all the error details. Every error always contains a "field" key that holds the value of err.Field()
Note in most cases, the err.Details() will be used to generate replacement strings in your locales, and not used directly. These strings follow the text/template format i.e.  {{.field}} must be greater than or equal to {{.min}}
The library allows you to specify custom template functions, should you require more complex error message handling.  gojsonschema.ErrorTemplateFuncs = map[string]interface{}{
"allcaps": func(s string) string {
return strings.ToUpper(s)
},
}
Given the above definition, you can use the custom function "allcaps" in your localization templates:  {{allcaps .field}} must be greater than or equal to {{.min}}
The above error message would then be rendered with the field value in capital letters. For example:  "PASSWORD must be greater than or equal to 8"
Learn more about what types of template functions you can use in ErrorTemplateFuncs by referring to Go's text/template FuncMap type.  Formats
JSON Schema allows for optional "format" property to validate instances against well-known formats. gojsonschema ships with all of the formats defined in the spec that you can use like this:  {"type": "string", "format": "email"}
Not all formats defined in draft-07 are available. Implemented formats are:   date  time  date-time  hostname . Subdomains that start with a number are also supported, but this means that it doesn't strictly follow RFC1034 and has the implication that ipv4 addresses are also recognized as valid hostnames.  email . Go's email parser deviates slightly from RFC5322 . Includes unicode support.  idn-email . Same caveat as email .  ipv4  ipv6  uri . Includes unicode support.  uri-reference . Includes unicode support.  iri  iri-reference  uri-template  uuid  regex . Go uses the RE2 engine and is not ECMA262 compatible.  json-pointer  relative-json-pointer
email , uri and uri-reference use the same validation code as their unicode counterparts idn-email , iri and iri-reference . If you rely on unicode support you should use the specific
unicode enabled formats for the sake of interoperability as other implementations might not support unicode in the regular formats.
The validation code for uri , idn-email and their relatives use mostly standard library code.
For repetitive or more complex formats, you can create custom format checkers and add them to gojsonschema like this:  // Define the format checker
type RoleFormatChecker struct {}

// Ensure it meets the gojsonschema.FormatChecker interface

func (f RoleFormatChecker) IsFormat(input interface{}) bool {

asString, ok := input.(string)
if ok == false {
return false
}

return strings.HasPrefix("ROLE_", asString)
}

// Add it to the library
gojsonschema.FormatCheckers.Add("role", RoleFormatChecker{})
Now to use in your json schema:  {"type": "string", "format": "role"}
Another example would be to check if the provided integer matches an id on database:
JSON schema:  {"type": "integer", "format": "ValidUserId"}  // Define the format checker
type ValidUserIdFormatChecker struct {}

// Ensure it meets the gojsonschema.FormatChecker interface

func (f ValidUserIdFormatChecker) IsFormat(input interface{}) bool {

asFloat64, ok := input.(float64) // Numbers are always float64 here
if ok == false {
return false
}

// XXX
// do the magic on the database looking for the int(asFloat64)

return true
}

// Add it to the library
gojsonschema.FormatCheckers.Add("ValidUserId", ValidUserIdFormatChecker{})
Formats can also be removed, for example if you want to override one of the formats that is defined by default.  gojsonschema.FormatCheckers.Remove("hostname")  Additional custom validation
After the validation has run and you have the results, you may add additional
errors using Result.AddError . This is useful to maintain the same format within the resultset instead
of having to add special exceptions for your own errors. Below is an example.  type AnswerInvalidError struct {
gojsonschema.ResultErrorFields
}


func newAnswerInvalidError(context *gojsonschema.JsonContext, value interface{}, details gojsonschema.ErrorDetails) *AnswerInvalidError {
err := AnswerInvalidError{}
err.SetContext(context)
err.SetType("custom_invalid_error")
// it is important to use SetDescriptionFormat() as this is used to call SetDescription() after it has been parsed
// using the description of err will be overridden by this.
err.SetDescriptionFormat("Answer to the Ultimate Question of Life, the Universe, and Everything is {{.answer}}")
err.SetValue(value)
err.SetDetails(details)

return &err
}


func main() {
// ...
schema, err := gojsonschema.NewSchema(schemaLoader)
result, err := gojsonschema.Validate(schemaLoader, documentLoader)

if true { // some validation
jsonContext := gojsonschema.NewJsonContext("question", nil)
errDetail := gojsonschema.ErrorDetails{
"answer": 42,
}
result.AddError(
newAnswerInvalidError(
gojsonschema.NewJsonContext("answer", jsonContext),
52,
errDetail,
),
errDetail,
)
}

return result, err

}
This is especially useful if you want to add validation beyond what the
json schema drafts can provide such business specific logic.  Uses
gojsonschema uses the following test suite :
https://github.com/json-schema/JSON-Schema-Test-Suite    Expand ▾  Collapse ▴
Documentation

Constants
View Source  const ( STRING_NUMBER                     = "number" STRING_ARRAY_OF_STRINGS           = "array of strings" STRING_ARRAY_OF_SCHEMAS           = "array of schemas" STRING_SCHEMA                     = "valid schema" STRING_SCHEMA_OR_ARRAY_OF_STRINGS = "schema or array of strings" STRING_PROPERTIES                 = "properties" STRING_DEPENDENCY                 = "dependency" STRING_PROPERTY                   = "property" STRING_UNDEFINED                  = "undefined" STRING_CONTEXT_ROOT               = "(root)" STRING_ROOT_SCHEMA_PROPERTY       = "(root)" )
constants
View Source  const ( KEY_SCHEMA                = "$schema" KEY_ID                    = "id" KEY_ID_NEW                = "$id" KEY_REF                   = "$ref" KEY_TITLE                 = "title" KEY_DESCRIPTION           = "description" KEY_TYPE                  = "type" KEY_ITEMS                 = "items" KEY_ADDITIONAL_ITEMS      = "additionalItems" KEY_PROPERTIES            = "properties" KEY_PATTERN_PROPERTIES    = "patternProperties" KEY_ADDITIONAL_PROPERTIES = "additionalProperties" KEY_PROPERTY_NAMES        = "propertyNames" KEY_DEFINITIONS           = "definitions" KEY_MULTIPLE_OF           = "multipleOf" KEY_MINIMUM               = "minimum" KEY_MAXIMUM               = "maximum" KEY_EXCLUSIVE_MINIMUM     = "exclusiveMinimum" KEY_EXCLUSIVE_MAXIMUM     = "exclusiveMaximum" KEY_MIN_LENGTH            = "minLength" KEY_MAX_LENGTH            = "maxLength" KEY_PATTERN               = "pattern" KEY_FORMAT                = "format" KEY_MIN_PROPERTIES        = "minProperties" KEY_MAX_PROPERTIES        = "maxProperties" KEY_DEPENDENCIES          = "dependencies" KEY_REQUIRED              = "required" KEY_MIN_ITEMS             = "minItems" KEY_MAX_ITEMS             = "maxItems" KEY_UNIQUE_ITEMS          = "uniqueItems" KEY_CONTAINS              = "contains" KEY_CONST                 = "const" KEY_ENUM                  = "enum" KEY_ONE_OF                = "oneOf" KEY_ANY_OF                = "anyOf" KEY_ALL_OF                = "allOf" KEY_NOT                   = "not" KEY_IF                    = "if" KEY_THEN                  = "then" KEY_ELSE                  = "else" )
Constants
View Source  const ( TYPE_ARRAY   = `array` TYPE_BOOLEAN = `boolean` TYPE_INTEGER = `integer` TYPE_NUMBER  = `number` TYPE_NULL    = `null` TYPE_OBJECT  = `object` TYPE_STRING  = `string` )
Type constants   Variables
View Source  var (  // Locale is the default locale to use   // Library users can overwrite with their own implementation Locale locale = DefaultLocale {}  // ErrorTemplateFuncs allows you to define custom template funcs for use in localization.  ErrorTemplateFuncs template . FuncMap )
View Source  var (  // FormatCheckers holds the valid formatters, and is a public variable   // so library users can add custom formatters FormatCheckers = FormatCheckerChain { // contains filtered or unexported fields }
)
View Source  var JSON_TYPES [] string
JSON_TYPES hosts the list of type that are supported in JSON
View Source  var SCHEMA_TYPES [] string
SCHEMA_TYPES hosts the list of type that are supported in schemas   Functions
This section is empty.  Types
type AdditionalPropertyNotAllowedError
type AdditionalPropertyNotAllowedError struct {  ResultErrorFields  }
AdditionalPropertyNotAllowedError is produced if an object has additional properties, but not allowed
ErrorDetails: property
type ArrayContainsError
type ArrayContainsError struct {  ResultErrorFields  }
ArrayContainsError is produced if an array contains invalid items
ErrorDetails:
type ArrayMaxItemsError
type ArrayMaxItemsError struct {  ResultErrorFields  }
ArrayMaxItemsError is produced if an array contains more items than the allowed maximum
ErrorDetails: max
type ArrayMaxPropertiesError
type ArrayMaxPropertiesError struct {  ResultErrorFields  }
ArrayMaxPropertiesError is produced if an object contains more properties than the allowed maximum
ErrorDetails: max
type ArrayMinItemsError
type ArrayMinItemsError struct {  ResultErrorFields  }
ArrayMinItemsError is produced if an array contains less items than the allowed minimum
ErrorDetails: min
type ArrayMinPropertiesError
type ArrayMinPropertiesError struct {  ResultErrorFields  }
ArrayMinPropertiesError is produced if an object contains less properties than the allowed minimum
ErrorDetails: min
type ArrayNoAdditionalItemsError
type ArrayNoAdditionalItemsError struct {  ResultErrorFields  }
ArrayNoAdditionalItemsError is produced if additional items were found, but not allowed
ErrorDetails: -
type ConditionElseError
type ConditionElseError struct {  ResultErrorFields  }
ConditionElseError is produced if a condition's "else" condition is invalid
ErrorDetails: -
type ConditionThenError
type ConditionThenError struct {  ResultErrorFields  }
ConditionThenError is produced if a condition's "then" validation is invalid
ErrorDetails: -
type ConstError
type ConstError struct {  ResultErrorFields  }
ConstError indicates a const error
ErrorDetails: allowed
type DateFormatChecker
type DateFormatChecker struct{}
DateFormatChecker verifies date formats
Valid format: Full Date: YYYY-MM-DD

Where
YYYY = 4DIGIT year
MM = 2DIGIT month ; 01-12
DD = 2DIGIT day-month ; 01-28, 01-29, 01-30, 01-31 based on month/year

func (DateFormatChecker) IsFormat

func (f DateFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted  date (YYYY-MM-DD)
type DateTimeFormatChecker
type DateTimeFormatChecker struct{}
DateTimeFormatChecker verifies date/time formats per RFC3339 5.6
Valid formats: Partial Time: HH:MM:SS
Full Date: YYYY-MM-DD
Full Time: HH:MM:SSZ-07:00
Date Time: YYYY-MM-DDTHH:MM:SSZ-0700

Where
YYYY = 4DIGIT year
MM = 2DIGIT month ; 01-12
DD = 2DIGIT day-month ; 01-28, 01-29, 01-30, 01-31 based on month/year
HH = 2DIGIT hour ; 00-23
MM = 2DIGIT ; 00-59
SS = 2DIGIT ; 00-58, 00-60 based on leap second rules
T = Literal
Z = Literal

Note: Nanoseconds are also suported in all formats
http://tools.ietf.org/html/rfc3339#section-5.6

func (DateTimeFormatChecker) IsFormat

func (f DateTimeFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted  date/time per RFC3339 5.6
type DefaultJSONLoaderFactory
type DefaultJSONLoaderFactory struct {
}
DefaultJSONLoaderFactory is the default JSON loader factory

func (DefaultJSONLoaderFactory) New

func (d DefaultJSONLoaderFactory ) New(source string ) JSONLoader
New creates a new JSON loader for the given source
type DefaultLocale
type DefaultLocale struct{}
DefaultLocale is the default locale for this package

func (DefaultLocale) AdditionalPropertyNotAllowed

func (l DefaultLocale ) AdditionalPropertyNotAllowed() string
AdditionalPropertyNotAllowed returns a format-string to format an AdditionalPropertyNotAllowedError

func (DefaultLocale) ArrayContains

func (l DefaultLocale ) ArrayContains() string
ArrayContains returns a format-string to format an ArrayContainsError

func (DefaultLocale) ArrayMaxItems

func (l DefaultLocale ) ArrayMaxItems() string
ArrayMaxItems returns a format-string to format an ArrayMaxItemsError

func (DefaultLocale) ArrayMaxProperties

func (l DefaultLocale ) ArrayMaxProperties() string
ArrayMaxProperties returns a format-string to format an ArrayMaxPropertiesError

func (DefaultLocale) ArrayMinItems

func (l DefaultLocale ) ArrayMinItems() string
ArrayMinItems returns a format-string to format an ArrayMinItemsError

func (DefaultLocale) ArrayMinProperties

func (l DefaultLocale ) ArrayMinProperties() string
ArrayMinProperties returns a format-string to format an ArrayMinPropertiesError

func (DefaultLocale) ArrayNoAdditionalItems

func (l DefaultLocale ) ArrayNoAdditionalItems() string
ArrayNoAdditionalItems returns a format-string to format an ArrayNoAdditionalItemsError

func (DefaultLocale) ArrayNotEnoughItems

func (l DefaultLocale ) ArrayNotEnoughItems() string
ArrayNotEnoughItems returns a format-string to format an error for arrays having not enough items to match positional list of schema

func (DefaultLocale) CannotBeGT

func (l DefaultLocale ) CannotBeGT() string
CannotBeGT returns a format-string to format an error where a value are greater than allowed

func (DefaultLocale) CannotBeUsedWithout

func (l DefaultLocale ) CannotBeUsedWithout() string
CannotBeUsedWithout returns a format-string to format a "cannot be used without" error

func (DefaultLocale) ConditionElse

func (l DefaultLocale ) ConditionElse() string
ConditionElse returns a format-string for ConditionElseError errors

func (DefaultLocale) ConditionThen

func (l DefaultLocale ) ConditionThen() string
ConditionThen returns a format-string for ConditionThenError errors
If/Else

func (DefaultLocale) Const

func (l DefaultLocale ) Const() string
Const returns a format-string to format a ConstError

func (DefaultLocale) DoesNotMatchFormat

func (l DefaultLocale ) DoesNotMatchFormat() string
DoesNotMatchFormat returns a format-string to format an DoesNotMatchFormatError

func (DefaultLocale) DoesNotMatchPattern

func (l DefaultLocale ) DoesNotMatchPattern() string
DoesNotMatchPattern returns a format-string to format an DoesNotMatchPatternError

func (DefaultLocale) Duplicated

func (l DefaultLocale ) Duplicated() string
Duplicated returns a format-string to format an error where types are duplicated

func (DefaultLocale) Enum

func (l DefaultLocale ) Enum() string
Enum returns a format-string to format an EnumError

func (DefaultLocale) ErrorFormat

func (l DefaultLocale ) ErrorFormat() string
ErrorFormat returns a format string for errors
Replacement options: field, description, context, value

func (DefaultLocale) False    added in  v1.2.0

func (l DefaultLocale ) False() string
False returns a format-string for "false" schema validation errors

func (DefaultLocale) GreaterThanZero

func (l DefaultLocale ) GreaterThanZero() string
GreaterThanZero returns a format-string to format an error where a number must be greater than zero

func (DefaultLocale) HttpBadStatus

func (l DefaultLocale ) HttpBadStatus() string
HttpBadStatus returns a format-string for errors when loading a schema using HTTP

func (DefaultLocale) Internal

func (l DefaultLocale ) Internal() string
Internal returns a format-string for internal errors

func (DefaultLocale) InvalidPropertyName

func (l DefaultLocale ) InvalidPropertyName() string
InvalidPropertyName returns a format-string to format an InvalidPropertyNameError

func (DefaultLocale) InvalidPropertyPattern

func (l DefaultLocale ) InvalidPropertyPattern() string
InvalidPropertyPattern returns a format-string to format an InvalidPropertyPatternError

func (DefaultLocale) InvalidType

func (l DefaultLocale ) InvalidType() string
InvalidType returns a format-string for "invalid type" schema validation errors

func (DefaultLocale) KeyCannotBeGreaterThan

func (l DefaultLocale ) KeyCannotBeGreaterThan() string
KeyCannotBeGreaterThan returns a format-string to format an error where a value is greater than the maximum  allowed

func (DefaultLocale) KeyItemsMustBeOfType

func (l DefaultLocale ) KeyItemsMustBeOfType() string
KeyItemsMustBeOfType returns a format-string to format an error where a key is of the wrong type

func (DefaultLocale) KeyItemsMustBeUnique

func (l DefaultLocale ) KeyItemsMustBeUnique() string
KeyItemsMustBeUnique returns a format-string to format an error where keys are not unique

func (DefaultLocale) MissingDependency

func (l DefaultLocale ) MissingDependency() string
MissingDependency returns a format-string for "missing dependency" schema validation errors

func (DefaultLocale) MultipleOf

func (l DefaultLocale ) MultipleOf() string
MultipleOf returns a format-string to format an MultipleOfError

func (DefaultLocale) MustBeGTEZero

func (l DefaultLocale ) MustBeGTEZero() string
MustBeGTEZero returns a format-string to format an error where a value must be greater or equal than 0

func (DefaultLocale) MustBeOfA

func (l DefaultLocale ) MustBeOfA() string
MustBeOfA returns a format-string to format an error where a value is of the wrong type

func (DefaultLocale) MustBeOfAn

func (l DefaultLocale ) MustBeOfAn() string
MustBeOfAn returns a format-string to format an error where a value is of the wrong type

func (DefaultLocale) MustBeOfType

func (l DefaultLocale ) MustBeOfType() string
MustBeOfType returns a format-string to format an error where a value does not match the required type

func (DefaultLocale) MustBeValidFormat

func (l DefaultLocale ) MustBeValidFormat() string
MustBeValidFormat returns a format-string to format an error where a value does not match the expected format

func (DefaultLocale) MustBeValidRegex

func (l DefaultLocale ) MustBeValidRegex() string
MustBeValidRegex returns a format-string to format an error where a regex is invalid

func (DefaultLocale) NotAValidType

func (l DefaultLocale ) NotAValidType() string
NotAValidType returns a format-string to format an invalid type error

func (DefaultLocale) NumberAllOf

func (l DefaultLocale ) NumberAllOf() string
NumberAllOf returns a format-string for "allOf" schema validation errors

func (DefaultLocale) NumberAnyOf

func (l DefaultLocale ) NumberAnyOf() string
NumberAnyOf returns a format-string for "anyOf" schema validation errors

func (DefaultLocale) NumberGT

func (l DefaultLocale ) NumberGT() string
NumberGT returns the format string to format a NumberGTError

func (DefaultLocale) NumberGTE

func (l DefaultLocale ) NumberGTE() string
NumberGTE returns the format string to format a NumberGTEError

func (DefaultLocale) NumberLT

func (l DefaultLocale ) NumberLT() string
NumberLT returns the format string to format a NumberLTError

func (DefaultLocale) NumberLTE

func (l DefaultLocale ) NumberLTE() string
NumberLTE returns the format string to format a NumberLTEError

func (DefaultLocale) NumberNot

func (l DefaultLocale ) NumberNot() string
NumberNot returns a format-string to format a NumberNotError

func (DefaultLocale) NumberOneOf

func (l DefaultLocale ) NumberOneOf() string
NumberOneOf returns a format-string for "oneOf" schema validation errors

func (DefaultLocale) ParseError

func (l DefaultLocale ) ParseError() string
ParseError returns a format-string for JSON parsing errors

func (DefaultLocale) ReferenceMustBeCanonical

func (l DefaultLocale ) ReferenceMustBeCanonical() string
ReferenceMustBeCanonical returns a format-string to format a "reference must be canonical" error

func (DefaultLocale) RegexPattern

func (l DefaultLocale ) RegexPattern() string
RegexPattern returns a format-string to format a regex-pattern error

func (DefaultLocale) Required

func (l DefaultLocale ) Required() string
Required returns a format-string for "required" schema validation errors

func (DefaultLocale) StringGTE

func (l DefaultLocale ) StringGTE() string
StringGTE returns a format-string to format an StringLengthGTEError

func (DefaultLocale) StringLTE

func (l DefaultLocale ) StringLTE() string
StringLTE returns a format-string to format an StringLengthLTEError

func (DefaultLocale) Unique

func (l DefaultLocale ) Unique() string
Unique returns a format-string  to format an ItemsMustBeUniqueError
type DoesNotMatchFormatError
type DoesNotMatchFormatError struct {  ResultErrorFields  }
DoesNotMatchFormatError is produced if a string does not match the defined format
ErrorDetails: format
type DoesNotMatchPatternError
type DoesNotMatchPatternError struct {  ResultErrorFields  }
DoesNotMatchPatternError is produced if a string does not match the defined pattern
ErrorDetails: pattern
type Draft
type Draft int
Draft is a JSON-schema draft version

const ( Draft4 Draft = 4 Draft6 Draft = 6 Draft7 Draft = 7 Hybrid Draft = math . MaxInt32  )
Supported Draft versions
type EmailFormatChecker
type EmailFormatChecker struct{}
EmailFormatChecker verifies email address formats

func (EmailFormatChecker) IsFormat

func (f EmailFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted e-mail address
type EnumError
type EnumError struct {  ResultErrorFields  }
EnumError indicates an enum error
ErrorDetails: allowed
type ErrorDetails
type ErrorDetails map[ string ]interface{}
ErrorDetails is a map of details specific to each error.
While the values will vary, every error will contain a "field" value
type FalseError    added in  v1.2.0
type FalseError struct {  ResultErrorFields  }
FalseError. ErrorDetails: -
type FileSystemJSONLoaderFactory
type FileSystemJSONLoaderFactory struct { // contains filtered or unexported fields }
FileSystemJSONLoaderFactory is a JSON loader factory that uses http.FileSystem

func (FileSystemJSONLoaderFactory) New

func (f FileSystemJSONLoaderFactory ) New(source string ) JSONLoader
New creates a new JSON loader for the given source
type FormatChecker
type FormatChecker interface {  // IsFormat checks if input has the correct format and type  IsFormat(input interface{}) bool }
FormatChecker is the interface all formatters added to FormatCheckerChain must implement
type FormatCheckerChain
type FormatCheckerChain struct { // contains filtered or unexported fields }
FormatCheckerChain holds the formatters

func (*FormatCheckerChain) Add

func (c * FormatCheckerChain ) Add(name string , f FormatChecker ) * FormatCheckerChain
Add adds a FormatChecker to the FormatCheckerChain
The name used will be the value used for the format key in your json schema

func (*FormatCheckerChain) Has

func (c * FormatCheckerChain ) Has(name string ) bool
Has checks to see if the FormatCheckerChain holds a FormatChecker with the given name

func (*FormatCheckerChain) IsFormat

func (c * FormatCheckerChain ) IsFormat(name string , input interface{}) bool
IsFormat will check an input against a FormatChecker with the given name
to see if it is the correct format

func (*FormatCheckerChain) Remove

func (c * FormatCheckerChain ) Remove(name string ) * FormatCheckerChain
Remove deletes a FormatChecker from the FormatCheckerChain (if it exists)
type HostnameFormatChecker
type HostnameFormatChecker struct{}
HostnameFormatChecker validates a hostname is in the correct format

func (HostnameFormatChecker) IsFormat

func (f HostnameFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted hostname
type IPV4FormatChecker
type IPV4FormatChecker struct{}
IPV4FormatChecker verifies IP addresses in the IPv4 format

func (IPV4FormatChecker) IsFormat

func (f IPV4FormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted IPv4-address
type IPV6FormatChecker
type IPV6FormatChecker struct{}
IPV6FormatChecker verifies IP addresses in the IPv6 format

func (IPV6FormatChecker) IsFormat

func (f IPV6FormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted IPv6=address
type InternalError
type InternalError struct {  ResultErrorFields  }
InternalError indicates an internal error
ErrorDetails: error
type InvalidPropertyNameError
type InvalidPropertyNameError struct {  ResultErrorFields  }
InvalidPropertyNameError is produced if an invalid-named property was found
ErrorDetails: property
type InvalidPropertyPatternError
type InvalidPropertyPatternError struct {  ResultErrorFields  }
InvalidPropertyPatternError is produced if an pattern was found
ErrorDetails: property, pattern
type InvalidTypeError
type InvalidTypeError struct {  ResultErrorFields  }
InvalidTypeError indicates that a field has the incorrect type
ErrorDetails: expected, given
type ItemsMustBeUniqueError
type ItemsMustBeUniqueError struct {  ResultErrorFields  }
ItemsMustBeUniqueError is produced if an array requires unique items, but contains non-unique items
ErrorDetails: type, i, j
type JSONLoader
type JSONLoader interface { JsonSource() interface{} LoadJSON() (interface{}, error ) JsonReference() ( gojsonreference . JsonReference , error ) LoaderFactory() JSONLoaderFactory  }
JSONLoader defines the JSON loader interface

func NewBytesLoader

func NewBytesLoader(source [] byte ) JSONLoader
NewBytesLoader creates a new JSONLoader, taking a `[]byte` as source

func NewGoLoader

func NewGoLoader(source interface{}) JSONLoader
NewGoLoader creates a new JSONLoader from a given Go struct

func NewRawLoader

func NewRawLoader(source interface{}) JSONLoader
NewRawLoader creates a new JSON raw loader for the given source

func NewReaderLoader

func NewReaderLoader(source io . Reader ) ( JSONLoader , io . Reader )
NewReaderLoader creates a new JSON loader using the provided io.Reader

func NewReferenceLoader

func NewReferenceLoader(source string ) JSONLoader
NewReferenceLoader returns a JSON reference loader using the given source and the local OS file system.

func NewReferenceLoaderFileSystem

func NewReferenceLoaderFileSystem(source string , fs http . FileSystem ) JSONLoader
NewReferenceLoaderFileSystem returns a JSON reference loader using the given source and file system.

func NewStringLoader

func NewStringLoader(source string ) JSONLoader
NewStringLoader creates a new JSONLoader, taking a string as source

func NewWriterLoader

func NewWriterLoader(source io . Writer ) ( JSONLoader , io . Writer )
NewWriterLoader creates a new JSON loader using the provided io.Writer
type JSONLoaderFactory
type JSONLoaderFactory interface {  // New creates a new JSON loader for the given source  New(source string ) JSONLoader }
JSONLoaderFactory defines the JSON loader factory interface
type JSONPointerFormatChecker
type JSONPointerFormatChecker struct{}
JSONPointerFormatChecker validates a JSON Pointer per RFC6901

func (JSONPointerFormatChecker) IsFormat

func (f JSONPointerFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted JSON Pointer per RFC6901
type JsonContext
type JsonContext struct { // contains filtered or unexported fields }
JsonContext implements a persistent linked-list of strings

func NewJsonContext

func NewJsonContext(head string , tail * JsonContext ) * JsonContext
NewJsonContext creates a new JsonContext

func (*JsonContext) String

func (c * JsonContext ) String(del ... string ) string
String displays the context in reverse.
This plays well with the data structure's persistent nature with
Cons and a json document's tree structure.
type MissingDependencyError
type MissingDependencyError struct {  ResultErrorFields  }
MissingDependencyError is produced in case of a "missing dependency" problem
ErrorDetails: dependency
type MultipleOfError
type MultipleOfError struct {  ResultErrorFields  }
MultipleOfError is produced if a number is not a multiple of the defined multipleOf
ErrorDetails: multiple
type NumberAllOfError
type NumberAllOfError struct {  ResultErrorFields  }
NumberAllOfError is produced in case of a failing "allOf" validation
ErrorDetails: -
type NumberAnyOfError
type NumberAnyOfError struct {  ResultErrorFields  }
NumberAnyOfError is produced in case of a failing "anyOf" validation
ErrorDetails: -
type NumberGTEError
type NumberGTEError struct {  ResultErrorFields  }
NumberGTEError is produced if a number is lower than the allowed minimum
ErrorDetails: min
type NumberGTError
type NumberGTError struct {  ResultErrorFields  }
NumberGTError is produced if a number is lower than, or equal to the specified minimum, and exclusiveMinimum is set
ErrorDetails: min
type NumberLTEError
type NumberLTEError struct {  ResultErrorFields  }
NumberLTEError is produced if a number is higher than the allowed maximum
ErrorDetails: max
type NumberLTError
type NumberLTError struct {  ResultErrorFields  }
NumberLTError is produced if a number is higher than, or equal to the specified maximum, and exclusiveMaximum is set
ErrorDetails: max
type NumberNotError
type NumberNotError struct {  ResultErrorFields  }
NumberNotError is produced if a "not" validation failed
ErrorDetails: -
type NumberOneOfError
type NumberOneOfError struct {  ResultErrorFields  }
NumberOneOfError is produced in case of a failing "oneOf" validation
ErrorDetails: -
type RegexFormatChecker
type RegexFormatChecker struct{}
RegexFormatChecker validates a regex is in the correct format

func (RegexFormatChecker) IsFormat

func (f RegexFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted regular expression
type RelativeJSONPointerFormatChecker
type RelativeJSONPointerFormatChecker struct{}
RelativeJSONPointerFormatChecker validates a relative JSON Pointer is in the correct format

func (RelativeJSONPointerFormatChecker) IsFormat

func (f RelativeJSONPointerFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted relative JSON Pointer
type RequiredError
type RequiredError struct {  ResultErrorFields  }
RequiredError indicates that a required field is missing
ErrorDetails: property string
type Result
type Result struct { // contains filtered or unexported fields }
Result holds the result of a validation

func Validate

func Validate(ls JSONLoader , ld JSONLoader ) (* Result , error )
Validate loads and validates a JSON schema

func (*Result) AddError

func (v * Result ) AddError(err ResultError , details ErrorDetails )
AddError appends a fully filled error to the error set
SetDescription() will be called with the result of the parsed err.DescriptionFormat()

func (*Result) Errors

func (v * Result ) Errors() [] ResultError
Errors returns the errors that were found

func (*Result) Valid

func (v * Result ) Valid() bool
Valid indicates if no errors were found
type ResultError
type ResultError interface {  // Field returns the field name without the root context   // i.e. firstName or person.firstName instead of (root).firstName or (root).person.firstName Field() string   // SetType sets the error-type  SetType( string )  // Type returns the error-type  Type() string   // SetContext sets the JSON-context for the error  SetContext(* JsonContext )  // Context returns the JSON-context of the error  Context() * JsonContext   // SetDescription sets a description for the error  SetDescription( string )  // Description returns the description of the error  Description() string   // SetDescriptionFormat sets the format for the description in the default text/template format  SetDescriptionFormat( string )  // DescriptionFormat returns the format for the description in the default text/template format  DescriptionFormat() string   // SetValue sets the value related to the error  SetValue(interface{})  // Value returns the value related to the error  Value() interface{}  // SetDetails sets the details specific to the error  SetDetails( ErrorDetails )  // Details returns details about the error  Details() ErrorDetails   // String returns a string representation of the error  String() string }
ResultError is the interface that library errors must implement
type ResultErrorFields
type ResultErrorFields struct { // contains filtered or unexported fields }
ResultErrorFields holds the fields for each ResultError implementation.
ResultErrorFields implements the ResultError interface, so custom errors
can be defined by just embedding this type

func (*ResultErrorFields) Context

func (v * ResultErrorFields ) Context() * JsonContext
Context returns the JSON-context of the error

func (*ResultErrorFields) Description

func (v * ResultErrorFields ) Description() string
Description returns the description of the error

func (*ResultErrorFields) DescriptionFormat

func (v * ResultErrorFields ) DescriptionFormat() string
DescriptionFormat returns the format for the description in the default text/template format

func (*ResultErrorFields) Details

func (v * ResultErrorFields ) Details() ErrorDetails
Details returns details about the error

func (*ResultErrorFields) Field

func (v * ResultErrorFields ) Field() string
Field returns the field name without the root context
i.e. firstName or person.firstName instead of (root).firstName or (root).person.firstName

func (*ResultErrorFields) SetContext

func (v * ResultErrorFields ) SetContext(context * JsonContext )
SetContext sets the JSON-context for the error

func (*ResultErrorFields) SetDescription

func (v * ResultErrorFields ) SetDescription(description string )
SetDescription sets a description for the error

func (*ResultErrorFields) SetDescriptionFormat

func (v * ResultErrorFields ) SetDescriptionFormat(descriptionFormat string )
SetDescriptionFormat sets the format for the description in the default text/template format

func (*ResultErrorFields) SetDetails

func (v * ResultErrorFields ) SetDetails(details ErrorDetails )
SetDetails sets the details specific to the error

func (*ResultErrorFields) SetType

func (v * ResultErrorFields ) SetType(errorType string )
SetType sets the error-type

func (*ResultErrorFields) SetValue

func (v * ResultErrorFields ) SetValue(value interface{})
SetValue sets the value related to the error

func (ResultErrorFields) String

func (v ResultErrorFields ) String() string
String returns a string representation of the error

func (*ResultErrorFields) Type

func (v * ResultErrorFields ) Type() string
Type returns the error-type

func (*ResultErrorFields) Value

func (v * ResultErrorFields ) Value() interface{}
Value returns the value related to the error
type Schema
type Schema struct { // contains filtered or unexported fields }
Schema holds a schema

func NewSchema

func NewSchema(l JSONLoader ) (* Schema , error )
NewSchema instances a schema using the given JSONLoader

func (*Schema) SetRootSchemaName

func (d * Schema ) SetRootSchemaName(name string )
SetRootSchemaName sets the root-schema name

func (*Schema) Validate

func (v * Schema ) Validate(l JSONLoader ) (* Result , error )
Validate loads and validates a JSON document
type SchemaLoader
type SchemaLoader struct { AutoDetect bool  Validate bool  Draft Draft   // contains filtered or unexported fields }
SchemaLoader is used to load schemas

func NewSchemaLoader

func NewSchemaLoader() * SchemaLoader
NewSchemaLoader creates a new NewSchemaLoader

func (*SchemaLoader) AddSchema

func (sl * SchemaLoader ) AddSchema(url string , loader JSONLoader ) error
AddSchema adds a schema under the provided URL to the schema cache

func (*SchemaLoader) AddSchemas

func (sl * SchemaLoader ) AddSchemas(loaders ... JSONLoader ) error
AddSchemas adds an arbritrary amount of schemas to the schema cache. As this function does not require
an explicit URL, every schema should contain an $id, so that it can be referenced by the main schema

func (*SchemaLoader) Compile

func (sl * SchemaLoader ) Compile(rootSchema JSONLoader ) (* Schema , error )
Compile loads and compiles a schema
type StringLengthGTEError
type StringLengthGTEError struct {  ResultErrorFields  }
StringLengthGTEError is produced if a string is shorter than the minimum required length
ErrorDetails: min
type StringLengthLTEError
type StringLengthLTEError struct {  ResultErrorFields  }
StringLengthLTEError is produced if a string is longer than the maximum allowed length
ErrorDetails: max
type TimeFormatChecker
type TimeFormatChecker struct{}
TimeFormatChecker verifies time formats
Valid formats: Partial Time: HH:MM:SS
Full Time: HH:MM:SSZ-07:00

Where
HH = 2DIGIT hour ; 00-23
MM = 2DIGIT ; 00-59
SS = 2DIGIT ; 00-58, 00-60 based on leap second rules
T = Literal
Z = Literal

func (TimeFormatChecker) IsFormat

func (f TimeFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input correctly formatted time (HH:MM:SS or HH:MM:SSZ-07:00)
type URIFormatChecker
type URIFormatChecker struct{}
URIFormatChecker validates a URI with a valid Scheme per RFC3986

func (URIFormatChecker) IsFormat

func (f URIFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is correctly formatted  URI with a valid Scheme per RFC3986
type URIReferenceFormatChecker
type URIReferenceFormatChecker struct{}
URIReferenceFormatChecker validates a URI or relative-reference per RFC3986

func (URIReferenceFormatChecker) IsFormat

func (f URIReferenceFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted URI or relative-reference per RFC3986
type URITemplateFormatChecker
type URITemplateFormatChecker struct{}
URITemplateFormatChecker validates a URI template per RFC6570

func (URITemplateFormatChecker) IsFormat

func (f URITemplateFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted URI template per RFC6570
type UUIDFormatChecker
type UUIDFormatChecker struct{}
UUIDFormatChecker validates a UUID is in the correct format

func (UUIDFormatChecker) IsFormat

func (f UUIDFormatChecker ) IsFormat(input interface{}) bool
IsFormat checks if input is a correctly formatted UUID
Source Files
View all Source files
draft.go   errors.go   format_checkers.go   internalLog.go   jsonContext.go   jsonLoader.go   locales.go   result.go   schema.go   schemaLoader.go   schemaPool.go   schemaReferencePool.go   schemaType.go   subSchema.go   types.go   utils.go   validation.go
Click to show internal directories.
Click to hide internal directories.

Why Go  Use Cases  Case Studies
Get Started  Playground  Tour  Stack Overflow  Help
Packages  Standard Library  Sub-repositories  About Go Packages
About  Download  Blog  Issue Tracker  Release Notes  Brand Guidelines  Code of Conduct
Connect  Twitter  GitHub  Slack  r/golang  Meetup  Golang Weekly
Copyright    Terms of Service    Privacy Policy    Report an Issue
Jump to



Close
Keyboard shortcuts
? : This menu    / : Search site    f or F : Jump to    y or Y  : Canonical URL
Close
go.dev uses cookies from Google to deliver and enhance the quality of its services and to
analyze traffic. Learn more.
Okay   // this will throw if the querySelector can’t find the element
const gtmId = document.querySelector('.js-gtmID').dataset.gtmid;
if (!gtmId) {
throw new Error('Google Tag Manager ID not found');
}
loadScript(`https://www.googletagmanager.com/gtm.js?id=${gtmId}`);

loadScript('/static/frontend/unit/main/main.js')  loadScript('/static/frontend/unit/unit.js')